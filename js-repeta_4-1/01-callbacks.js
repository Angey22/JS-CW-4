/*
 * Функция обратного вызова (callback)
 * - Функция может принимать другие функции как параметры
 * - Функция которая передаётся другой функции как аргумент называетс
 *   «функцией обратного (отложенного) вызова» (callback-функция)
 * - Функция которая принимает другую функцию как параметр
 *   или возвращает функцию как результат своей работы называется «функцией высшего порядка»
 */

// Пример-пояснение для вышеописанного теоритического правила.

// "fnA" - является "фуннкцией высшего порядка", т.к. она принимает в качестве параметра другую функцию - "fnB".
const fnA = function (message, callback) {
    console.log(message); // Выводим в консоль содержимое 1-го аргумента функции

    console.log(callback); // Выводим в консоль содержимое 2-го аргумента функции

    callback(100); // Задаем числовой параметр функции отложенного вызова ("fnB"), которая "приходит" в функ-ию "fnA" в качестве параметра, под именем - "callback".
};

// "fnB" - является "функцией обратного (отложенного) вызова (или иначе - "callback-функцией")", т.к. она передаётся другой функции - "fnA", как аргумент.
const fnB = function (number) {
    console.log('Это лог при вызове fnB', number);
};

// Производим операцию вызова функции "fnA"
fnA('qweqwe', fnB);


console.log('******************************************');
// *******************************************************



/*
 * функция doMath(a, b, callback)
 */

// "doMath" - является "фуннкцией высшего порядка", т.к. она принимает в качестве параметра другуие функции, под именем переменной - "callback".
const doMath = function (a, b, callback) {
    const result = callback(a, b); // Вызываем принимаемую в качестве аргумента функцию и передаем ей значения.

    console.log('Лог функции "doMath" =>', result); // Выводим в лог результат вычисления функции отложенного вызова.
};

// "add" - является "функцией обратного (отложенного) вызова (или иначе - "callback-функцией")", т.к. она передаётся другой функции - "doMath", как аргумент.
const add = function (x, y) {
    return x + y;
};

// "sub" - является "функцией обратного (отложенного) вызова (или иначе - "callback-функцией")", т.к. она передаётся другой функции - "doMath", как аргумент.
const sub = function (x, y) {
    return x - y;
};

// Производим операцию вызова функции "doMath" и передаем ей в качестве аргументов 2-а числа и ссылку на функцию отложенного вызова - "add"
console.log('Вызов функции "doMath", с использованием отдельно-записанной функции "add":')
doMath(2, 3, add);

// Производим операцию вызова функции "doMath" и передаем ей в качестве аргументов 2-а числа и записанный прямо в условие - код функции отложенного вызова, которая содержит нужные свойства - "сложения". Такой вид записи позволяет - не использовать лишних переменных в скрипте и отказаться от необходимости отдельно писать функции "add", в данном случае.
console.log('Вызов функции "doMath", с использованием записанной прямо в код вызова, функции с нужными свой-ми "сложения":');
doMath(2, 3, function (x, y) {
    return x + y;
});

// Производим операцию вызова функции "doMath" и передаем ей в качестве аргументов 2-а числа и ссылку на функцию отложенного вызова - "sub"
console.log('Вызов функции "doMath", с использованием отдельно-записанной функции "sub":')
doMath(10, 8, sub);

// Производим операцию вызова функции "doMath" и передаем ей в качестве аргументов 2-а числа и записанный прямо в условие - код функции отложенного вызова, которая содержит нужные свойства - "сложения". Такой вид записи позволяет - не использовать лишних переменных в скрипте и отказаться от необходимости отдельно писать функции "sub", в данном случае.
console.log('Вызов функции "doMath", с использованием записанной прямо в код вызова, функции с нужными свой-ми "вычитания":');
doMath(10, 8, function (x, y) {
    return x - y;
});


// Дополнительно нужно отметить, что функции которые присваиваются в какуюто переменную, предназначены для переиспользования много раз. В тоже время, бывают так называемые "анонимные" функции, это функции которые используются один раз, и для которых нет смысла или специально ненужно создавать отдельную переменную или записывать их в виде отдельной функции находящейся в скрипте. Подобные ананимные или "инлайн" или "встроенные" функции записываются в виде "литерала функции" прямо в условие другой функции.



console.log('******************************************');
// *******************************************************



/*
 * Отложенный вызов: "регистрация событий"
 * или "регистрация отложенного события".
 */

// Важный "use case", который описывает единственный способ запрограммировать исполнение нужного фрагмента кода JS скрипта - "по событию". Например, по событию - "клика" на кнопке.

// "Привязываем" переменную "buttonRef" к HTML объекту. Операцию "привязывания" выполняем с помощью кода "document.querySelector('текст имени селектора-привязки')". В котором "document" - указывает на то, что объект привязки расположен в коде HTML документа, а "querySelector()" - метод обазначения соответствующего селектора, описываемого текстовыми символами внутри скобок метода.
const buttonRef = document.querySelector('.js-button');

// Выводим в консоль содержимое переменной "buttonRef"
console.log('Проверяем переменную "buttonRef" на преобразование в JS объект');
console.dir(buttonRef);

// Создаем функцию обратного (отложенного) вызова (или иначе - "callback-функцией"), которая должна активироваться при "клике" на соответствующую кнопку, рассположенную в разметке HTML документа.
const handleBtnClick = function () {
    console.log('Клик по кнопке ' + Date.now());
};

// Задаем параметры отслеживания объекта "buttonRef" с помощью метода "addEventListener()". В котором (в скобках) нужно указать индикатор отслеживаемого события - 'click', и функцию или ответное действие, которое необходимо выполнять, когда происходит отслеживаемое событие.
buttonRef.addEventListener('click', handleBtnClick);

// Соответствующая надпись - будет появлятся в самой нижней части лога, после всех имеющихся в скрипте кодов сообщений, не смотря на то, что этот код находится в середине текста скрипта. Дело в том, что отслеживаемое событие - "клик" на кнопку, происходит после того как в этом скрипте был написан код, соответственно и выводимые функцией "handleBtnClick" лог сообщения - будут отображаться в самом низу логов отображаемых в консоле.

// Пример записи предыдущей команды с ипользованием в качестве второго аргумента не переменной (которой присвоено значение в виде функции), а анонимной - инлайн функции, записаной прямо в условие метода "addEventListener".
// buttonRef.addEventListener('click', function () {
//     console.log('Клик по кнопке ' + Date.now());
// });


console.log('******************************************');
// *******************************************************



/*
 * Отложенный вызов: геолокация
 */
// Пример функций из которых не чего не возвращается само по себе. Для того, чтобы данный тип функций выполнил что-то, в них нужно "положить" функции "с отложенным вызовом" в качестве аргументов. Данный тип функций высшего порядка, как правило, основываются на контакте с пользователями или событиями, в результате которых запускается их выполнение. Примером такого вида функций может выступать функция предназначеная для определения текущего местоположения пользователя, при активации которой - пользователь должен дать разрешение на определение своего местоположения. При этом, сама функция активируется только в том случае, если ей в качестве аргумента будут заданы 2-е функции отложенного действия: 1-я, в которой описан алгоритм действий программы при "разрешении" на определение местоположения пользователя, и 2-я, в которой описываются действия - при "запрете".

// Например, для выполнения процедуры поиска текущей геолокации, т.е. запуска функции "определения геолокации", в неё (в функцию определения геолокации) нужно "положить" (отправить в качестве аргументов) две функции с отложенным действием: 1-ю, в которой будет описываться набор действий при успешном выполнении процедуры поиска геолокации, и 2-ю, в которой будут описываться действия, при возникновении ошибки выполнения процедуры поиска геолокации.

// Отложенная функция описывающая действия при "успехе" выполнения процедуры поиска геолокации
const onGetPositionSuccess = function (position) {
    console.log('Это вызов onGetPositionSuccess');
    console.log(position);
};

// Отложенная функция описывающая действия при "ошибке" выполнения процедуры поиска геолокации
const onGetPositionError = function (error) {
    console.log('Это вызов onGetPositionError');
    console.log(error);
};

// Команда активации процедуры поиска текущей геолокации пользователя
window.navigator.geolocation.getCurrentPosition(
    onGetPositionSuccess,
    onGetPositionError,
);



console.log('******************************************');
// *******************************************************



/*
 * Отложенный вызов: интервалы
 */
// Существует метод "setTimeout()", который позволяет производить отложенный по таймеру вызов функций. Синтаксическая запись параметров данного метода состоит из записи 2-х параметров: 1) переменной с функцией или имя функции, или записи анонимной функции прямо в условие (литерала функции); 2) числовое значение задержки запуска указанной в 1-м параметре отложенной функции, которое задается в милисекундах.

// Отложенная функция, которая запускается по таймауту
const callback = function () {
    console.log('Через 2 секунды внутри колбека в таймауте');
};

// Обозначаем фрагмент кода перед вызовом отложенной функции
console.log('В коде перед таймаутом');

// Вызов отложенной функции через метод "setTimeout()"
setTimeout(callback, 2000);

// Обозначаем фрагмент кода после вызова отложенной функции
console.log('В коде после таймаута');

// Интересным является то, что как и в предудуще описанном примере с геолокацией, лог отложенной функции отображается в консоли - в самом низу...



console.log('******************************************');
// *******************************************************



/*
 * Отложенный вызов: http-запрос
 * - API URL: https://pokeapi.co/api/v2/pokemon
 */
// Еще один пример создания отложенных функций
console.log('Код отложенной функции - обработчика получаемых от удаленного сервиса данных');

// Отложенная функция, которая запускается после получения с сервиса необходимых данных
const onRequestSuccess = function (response) {
    console.log(
        'Вызов функции onRequestSuccess после успешного ответа бекенда',
    );
    console.log(response);
};

// Метод-обращение к удаленному сервису, например за получением набора данных. После получения соответствующих данных - активируется выше описанная функция отложенного вызова.
fetch('https://pokeapi.co/api/v2/pokemon')
    .then(res => res.json())
    .then(onRequestSuccess);

// Как и в предудуще описанных примерах, лог отложенной функции отображается в консоли - в самом низу...



console.log('******************************************');
// *******************************************************



/*
 * Фильтр
 */
// Пример функции-фильтр для фильтрации (обработки определенным образом) массива по какому-то заданному условию.

const filter = function (array, test) {
    const filteredArray = [];

    for (const el of array) {
        console.log(el);
        const passed = test(el);

        if (passed) {
            filteredArray.push(el);
        }
    }

    return filteredArray;
};

// Логика работы функции-проверки:
// 1. надо передать функцию
// 2. функция получает элемент массива
// 3.1. если элемент массива удовлетворяет условию то функция вернет true
// 3.2. если элемент массива НЕ удовлетворяет условию то функция вернет false

const callback1 = function (value) {
    return value >= 3;
};

const r1 = filter([1, 2, 3, 4, 5], callback1);
console.log(r1);

const callback2 = function (value) {
    return value <= 4;
};

const r2 = filter([1, 2, 3, 4, 5, 6, 7, 8], callback2);
console.log(r2);



const fruits = [
    { name: 'apples', quantity: 200, isFresh: true },
    { name: 'grapes', quantity: 150, isFresh: false },
    { name: 'bananas', quantity: 100, isFresh: true },
];

const getFruitsWithQuantity = function (fruit) {
    return fruit.quantity >= 120;
};

const r3 = filter(fruits, getFruitsWithQuantity);
console.log(r3);